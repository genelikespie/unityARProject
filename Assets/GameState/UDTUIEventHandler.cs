/*============================================================================== 
 * Copyright (c) 2012-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved. 
 * ==============================================================================*/
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Vuforia;

/// <summary>
/// UI Event Handler class that handles events generated by user-tap actions
/// over the UI Options Menu
/// </summary>
public class UDTUIEventHandler : MonoBehaviour { 
	
	#region PRIVATE_MEMBER_VARIABLES
	private static bool sExtendedTrackingIsEnabled = false;
	#endregion PRIVATE_MEMBER_VARIABLES
	
	
	#region PUBLIC_MEMBER_PROPERTIES
	/// <summary>
	/// Currently, there is no mechanism to query the SDK to know whether or not extended tracking is enabled/disabled.
	/// Therefore, it needs to be handled at the app layer.
	/// </value>
	public static bool ExtendedTrackingIsEnabled
	{
		get {
			return sExtendedTrackingIsEnabled;
		}
	}
	#endregion PUBLIC_MEMBER_PROPERTIES
	
	#region PUBLIC_METHODS
	public void Start()
	{
		// Register functions for Vuforia started callback
		// Functions can be called in code to trigger different types of camera focus modes.
		VuforiaAbstractBehaviour vuforiaBehaviour = (VuforiaAbstractBehaviour)FindObjectOfType(typeof(VuforiaAbstractBehaviour));
		if (vuforiaBehaviour)
		{
			vuforiaBehaviour.RegisterVuforiaStartedCallback(EnableContinuousAutoFocus);
			vuforiaBehaviour.RegisterOnPauseCallback(OnPause);
		}
		
		//ExtendedTracking(sExtendedTrackingIsEnabled);
	}
	
	public void OnDestroy()
	{ 
		// unregister Vuforia started callback
		VuforiaAbstractBehaviour vuforiaBehaviour = (VuforiaAbstractBehaviour)FindObjectOfType(typeof(VuforiaAbstractBehaviour));
		if (vuforiaBehaviour)
		{
			vuforiaBehaviour.UnregisterVuforiaStartedCallback(EnableContinuousAutoFocus);
			vuforiaBehaviour.UnregisterOnPauseCallback(OnPause);
		}
		
		sExtendedTrackingIsEnabled = false;
	}
	
	//SingleTap Gestures are captured by AppManager and calls this method for TapToFocus
	public void TriggerAutoFocus()
	{
		StartCoroutine(TriggerAutoFocusAndEnableContinuousFocusIfSet());
	}
	
	#endregion PUBLIC_METHODS
	
	#region PRIVATE_METHODS
	
	
	/// <summary>
	/// Activating trigger autofocus mode unsets continuous focus mode (if was previously enabled from the UI Options Menu)
	/// So, we wait for a second and turn continuous focus back on (if options menu shows as enabled)
	/// </returns>
	private IEnumerator TriggerAutoFocusAndEnableContinuousFocusIfSet()
	{
		//triggers a single autofocus operation 
		if (CameraDevice.Instance.SetFocusMode(CameraDevice.FocusMode.FOCUS_MODE_TRIGGERAUTO)) {
			Debug.Log ("Changed to trigger autofocus mode.");
		}
		
		yield return new WaitForSeconds(1.0f);
		
		//continuous focus mode is turned back on 
		if (CameraDevice.Instance.SetFocusMode(CameraDevice.FocusMode.FOCUS_MODE_CONTINUOUSAUTO)) {
			Debug.Log ("Changed to continuous autofocus mode.");
		}
	}
	
	private void OnPause(bool pause)
	{
		if (!pause)
		{
			// set to continous autofocus
			CameraDevice.Instance.SetFocusMode(CameraDevice.FocusMode.FOCUS_MODE_CONTINUOUSAUTO);
		}
	}
	
	//We want autofocus to be enabled when the app starts
	private void EnableContinuousAutoFocus()
	{
		OnTappedToTurnOnTracking(false);
		if (CameraDevice.Instance.SetFocusMode(CameraDevice.FocusMode.FOCUS_MODE_CONTINUOUSAUTO))
		{
			Debug.Log ("Enabled to continuous autofocus mode.");
		}
	}
	
	// Function to toggle extended tracking.
	public void OnTappedToTurnOnTracking(bool tf)
	{
		sExtendedTrackingIsEnabled = tf;
		if(!ExtendedTracking(tf))
		{
			sExtendedTrackingIsEnabled = false;
			Debug.Log ("Extended Tracking not supported.");
		}
		else
		{
			Debug.Log ("Toggling Extended Tracking state.");
		}
	}
	
	
	private bool stopRunningObjectTracker()
	{
		bool needsObjectTrackerRestart = false;
		
		ObjectTracker objectTracker = TrackerManager.Instance.GetTracker<ObjectTracker>();
		if (objectTracker != null)
		{
			if (objectTracker.IsActive)
			{
				objectTracker.Stop();
				needsObjectTrackerRestart = true;
			}
		}
		return needsObjectTrackerRestart;
	}
	
	private bool restartRunningObjectTracker()
	{
		bool hasObjectTrackerRestarted = false;
		
		ObjectTracker objectTracker = TrackerManager.Instance.GetTracker<ObjectTracker>();
		if (objectTracker != null)
		{
			if (!objectTracker.IsActive)
			{
				hasObjectTrackerRestarted = objectTracker.Start();
			}
		}
		return hasObjectTrackerRestarted;
	}
	
	// Resets camera direction to facing back.
	public void ResetCameraFacingToBack()
	{
		bool needsObjectTrackerRestart = stopRunningObjectTracker();
		
		CameraDevice.Instance.Stop();
		CameraDevice.Instance.Init(CameraDevice.CameraDirection.CAMERA_BACK);
		CameraDevice.Instance.Start();
		
		if (needsObjectTrackerRestart)
			restartRunningObjectTracker();
	}
	
	// Changes camera direction.
	public bool ChangeCameraDirection(CameraDevice.CameraDirection direction)
	{
		bool directionSupported = false;
		
		bool needsObjectTrackerRestart = stopRunningObjectTracker();
		
		CameraDevice.Instance.Stop();
		CameraDevice.Instance.Deinit();
		if (CameraDevice.Instance.Init(direction))
		{
			directionSupported = true;
		}
		CameraDevice.Instance.Start();
		
		if (needsObjectTrackerRestart)
			restartRunningObjectTracker();
		
		return directionSupported;
	}
	
	/// <summary>
	/// This method turns extended tracking on or off for all currently available targets.
	/// Extended tracking allows to track targets when they are not in view.
	/// Returns true of extended tracking is supported; false otherwise
	/// </summary>
	private bool ExtendedTracking(bool tf)
	{
		// the StateManager gives access to all available TrackableBehavours
		StateManager stateManager = TrackerManager.Instance.GetStateManager();
		
		// We iterate over all TrackableBehaviours to start or stop extended tracking for the targets they represent.
		foreach(var behaviour in stateManager.GetTrackableBehaviours())
		{
			var imageBehaviour = behaviour as ImageTargetBehaviour;
			if(imageBehaviour != null)
			{
				imageBehaviour.ImageTarget.StopExtendedTracking();
			}
		}
		
		//As of now, UserDefinedTargets can handle Enable/Disable ExtendedTracking on only one TrackableBehaviour.
		//So, we find the latest TrackableBehaviour from the set of user-defined targets and start/stop extended tracking on it.
		List<TrackableBehaviour> list =  stateManager.GetTrackableBehaviours().ToList();
		
		if (list.Count > 0)
		{
			UserDefinedTargetEventHandler component = FindObjectOfType<UserDefinedTargetEventHandler>() as UserDefinedTargetEventHandler;
			
			ImageTargetBehaviour bhvr = list[ component.IndexForMostRecentlyAddedTrackable ] as ImageTargetBehaviour;
			Debug.Log("OTT For ImageTargetBehaviour " + bhvr.gameObject.name + " enabled");
			if (bhvr != null)
			{
				if (tf)
				{
					if (bhvr.ImageTarget.StartExtendedTracking())
					{
						return true;
					}
					else
					{
						Debug.LogWarning("Extended Tracking is not supported on this device");
						return false;
					}
				}
				else
				{
					if (bhvr.ImageTarget.StopExtendedTracking())
					{
						return true;
					}
					else
					{
						Debug.LogWarning("Extended Tracking is not supported on this device");
						return false;
					}
				}
			}
		}
		else
		{
			return tf;
		}
		
		return tf;
	}
	
	#endregion PRIVATE_METHODS
	
}

